#include "video.cuh"
#include "image.cuh"

#include <string>
#include <stdexcept>
#include <regex>

void waveletFilterSequence(std::string inputPath, std::string outputPath){
    int streamCount = 5;
    const int2 shape = {1920, 1080};
    const dim3 blockSize(16, 16);
    const int frameCount = 20;
    //TODO get shape from

    CPUVector<int> frameOutput(streamCount);

    dim3 gridSize((shape.x + 15) / 16, (shape.y + 15) / 16);
    int pixelCount = totalSize(shape);
    int byteCount = sizeof(Pixel) * pixelCount;

    float scaleSigma = 3*255*2;
    FilterParams params = {FilterParams::WAVELET, 2, 0, .1f*scaleSigma, .1f*scaleSigma, .1f*scaleSigma, .1f*scaleSigma};

    CPUVector<CudaFramebuffer> frames(streamCount);
    CPUVector<cudaStream_t> streams(streamCount);

    std::regex pattern(R"(\$frame\$)");

    for(int i = 0; i < streamCount; i++){
        frames[i].allocate(shape);
        cudaStreamCreate(&streams[i]);
        frameOutput[i] = -1;
    }

    for(int frameIdx = 0; frameIdx < frameCount + streamCount; frameIdx++){
        int streamIdx = frameIdx%streamCount;
        int videoIdx = (frameIdx-streamCount)%streamCount;
        auto& frame = frames[streamIdx];
        auto stream = streams[streamIdx];

        if(frameIdx >= streamCount){
            cudaStreamSynchronize(streams[streamIdx]);

            saveImage(
                outputPath + std::to_string(videoIdx + 1) + ".png",
                frame.denoisedCPU, shape);
        }
        if(frameIdx < frameCount){
            frame.openImages(std::regex_replace(inputPath, pattern, std::to_string(frameIdx+1)));

            waveletKernel<<<gridSize, blockSize, 0, stream>>>(frame, params);

            cudaMemcpyAsync(frame.denoisedCPU, frame.denoised, sizeof(Pixel) * totalSize(shape), cudaMemcpyDeviceToHost, stream);
        }
    }

    for(int i = 0; i < streamCount; i++)
        cudaStreamDestroy(streams[i]);

}